(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{117:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return i})),a.d(t,"toc",(function(){return s})),a.d(t,"default",(function(){return o}));var n=a(3),l=a(7),r=(a(0),a(132)),c={sidebar_position:2,title:"Load"},i={unversionedId:"concepts/load",id:"concepts/load",isDocsHomePage:!1,title:"Load",description:"Domain",source:"@site/docs/concepts/load.md",sourceDirName:"concepts",slug:"/concepts/load",permalink:"/comet-data-pipeline/docs/concepts/load",editUrl:"https://github.com/ebiznext/comet-data-pipeline/edit/master/docs/docs/concepts/load.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Load"},sidebar:"cometSidebar",previous:{title:"Extract",permalink:"/comet-data-pipeline/docs/concepts/extract"},next:{title:"Transform",permalink:"/comet-data-pipeline/docs/concepts/transform"}},s=[{value:"Domain",id:"domain",children:[]},{value:"Schema",id:"schema",children:[]},{value:"Metadata",id:"metadata",children:[]},{value:"Attribute",id:"attribute",children:[]},{value:"Sink",id:"sink",children:[{value:"BigQuerySink",id:"bigquerysink",children:[]},{value:"EsSink",id:"essink",children:[]},{value:"JdbcSink",id:"jdbcsink",children:[]}]},{value:"RowLevelSecurity",id:"rowlevelsecurity",children:[]}],b={toc:s};function o(e){var t=e.components,a=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"domain"},"Domain"),Object(r.b)("p",null,"Let's say you are willing to import customers and orders from your Sales system.\nSales is therefore the domain and customer & order are your datasets."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"In a DBMS, a Domain would be implemented by a DBMS  schema and a dataset by a DBMS table."),Object(r.b)("li",{parentName:"ul"},"In BigQuery, the domain name would be the Big Query dataset name and the dataset would be implemented by a Big Query table.")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"name: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". Domain name. Make sure you use a name that may be used as a folder name on the target storage."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"When using HDFS or Cloud Storage,  files once ingested are stored in a sub-directory oof a directory named after the domain name."),Object(r.b)("li",{parentName:"ul"},"When used with BigQuery, files are ingested and sorted in tables under a dataset named after the domain name.")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"directory: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),'. Folder on the local filesystem where incoming files are stored.\nTypically, this folder will be scanned periodically to move the dataset to the cluster for ingestion.\nFiles located in this folder are moved to the pending folder for ingestion by the "import" command.'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"metadata: Metadata\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Default Schema metadata.\nThis metadata is applied to the schemas defined in this domain.\nMetadata properties may be redefined at the schema level.\nSee Metadata Entity for more details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"schemas: List[Schema]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". List of schemas for each dataset in this domain\nA domain ususally contains multiple schemas. Each schema defining how the contents of the input file should be parsed.\nSee :ref:",Object(r.b)("inlineCode",{parentName:"p"},"schema_concept")," for more details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"comment: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Domain Description (free text)"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"extensions: List[String]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Recognized filename extensions. json, csv, dsv, psv are recognized by default\nOnly files with these extensions will be moved to the pending folder."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"ack: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),'.\nAck extension used for each file. ".ack" if not specified.\nFiles are moved to the pending folder only once a file with the same name as the source file and with this extension is present.\nTo move a file without requiring an ack file to be present, set explicitly this property to the empty string value "".'),Object(r.b)("h2",{id:"schema"},"Schema"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"name: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". Schema name, must be unique among all the schemas belonging to the same domain.\nWill become a hive table name On Premise or BigQuery table name on GCP."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"pattern: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". Filename pattern to which this schema must be applied. This may be any Java Regex\nThis instructs the framework to use this schema to parse any file with a filename that match this pattern."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"attributes: List[Attribute]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". Attributes parsing rules.\nSee :ref:",Object(r.b)("inlineCode",{parentName:"p"},"attribute_concept")," for more details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"metadata: Metadata\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Dataset metadata\nSee :ref:",Object(r.b)("inlineCode",{parentName:"p"},"metadata_concept")," for more details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"comment: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Free text"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"presql: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Reserved for future use."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"postsql: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Reserved for future use."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"tags: Set[String]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Set of string to attach to this Schema"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"rls: List[RowLevelSecurity]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Experimental. Row level security to apply to this schema once it is ingested.\nThis usually execute a set on grants by applying a predicate filter to restrict\naccess to a subset of the rows in the table.\nSee :ref:",Object(r.b)("inlineCode",{parentName:"p"},"rls_concept")," for more details"),Object(r.b)("h2",{id:"metadata"},"Metadata"),Object(r.b)("p",null,"Specify Schema properties.\nThese properties may be specified at the schema or domain level\nAny property not specified at the schema level is taken from the\none specified at the domain level or else the default value is returned."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"mode: Enum\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". FILE mode by default. FILE and STREAM are the two accepted values. FILE is currently the only supported mode."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"format: Enum\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". DSV by default. Supported file formats are :"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'DSV : Delimiter-separated values file. Delimiter value iss specified in the "separator" field.'),Object(r.b)("li",{parentName:"ul"},"POSITION : FIXED format file where values are located at an exact position in each line."),Object(r.b)("li",{parentName:"ul"},"SIMPLE_JSON : For optimisation purpose, we differentiate JSON with top level values from JSON with deep level fields. SIMPLE_JSON are JSON files with top level fields only."),Object(r.b)("li",{parentName:"ul"},"JSON :  Deep JSON file. Use only when your json documents contain subdocuments, otherwise prefer to use SIMPLE_JSON since it is much faster."),Object(r.b)("li",{parentName:"ul"},"XML : For XML files")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"encoding: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". UTF-8 if not specified."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"multiline: Boolean\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Are json objects on a single line or multiple line ? Single by default.  false means single. false also means faster"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"array: Boolean\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Is the json stored as a single object array ? false by default. This means that by default we have on json document per line."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"withHeader: Boolean\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". When the input file is in the DSV file format, does the dataset has a header ? true bu default"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"separator: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". When the input file is in the DSV file format, yhiss field contains the values delimiter,  ';' by default value may be a multichar string starting from Spark 3"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"uote: Char\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". The String quote char, '\"' by default"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"escape: Char\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Escaping char '\\' by default"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"write: Enum\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Write mode, APPEND by default"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"partition: List[String]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Partition columns, no partitioning by default"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"sink: Sink\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Should the dataset be indexed to this sink ?\nSee :ref:",Object(r.b)("inlineCode",{parentName:"p"},"sink_concept")," for more details."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"ignore: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Optional"),". Pattern to ignore or UDF to apply to ignore some lines"),Object(r.b)("h2",{id:"attribute"},"Attribute"),Object(r.b)("p",null,'A field in the schema. For struct fields, the field "attributes" contains all sub attributes'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"name: String\n")),Object(r.b)("p",null,"Attribute name as defined in the source dataset and as received in the file"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"type: String\n")),Object(r.b)("p",null,"Semantic type of the attribute."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"array: Boolean\n")),Object(r.b)("p",null,"Is it an array ?"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"required: Boolean\n")),Object(r.b)("p",null,"Should this attribute always be present in the source"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"privacy:PrivacyLevel\n")),Object(r.b)("p",null,"Should this attribute be applied a privacy transformation at ingestion time"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"comment: String\n")),Object(r.b)("p",null,"free text for attribute description"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"rename: String\n")),Object(r.b)("p",null,"If present, the attribute is renamed with this name"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"metricType:MetricType\n")),Object(r.b)("p",null,"If present, what kind of stat should be computed for this field"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"attributes: List[Attribute]\n")),Object(r.b)("p",null,"List of sub-attributes (valid for JSON and XML files only)"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"position: Position\n")),Object(r.b)("p",null,"Valid only when file format is POSITION"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"default: String\n")),Object(r.b)("p",null,"Default value for this attribute when it is not present."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"tags:Set[String]\n")),Object(r.b)("p",null,"Tags associated with this attribute"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"trim: Trim\n")),Object(r.b)("p",null,"Should we trim the attribute value ?"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"script: String\n")),Object(r.b)("p",null,"Scripted field : SQL request on renamed column"),Object(r.b)("h2",{id:"sink"},"Sink"),Object(r.b)("p",null,"Once ingested, files may be sinked to BigQuery, Elasticsearch or any JDBC compliant Database."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"type: Enum\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"JDBC : dataset will be sinked to a JDBC Database. See JdbcSink below"),Object(r.b)("li",{parentName:"ul"},"ES : dataset is indexed into Elasticsearch. See EsSink below"),Object(r.b)("li",{parentName:"ul"},"BQ : Dataset is sinked to BigQuery. See BigQuerySink below"),Object(r.b)("li",{parentName:"ul"},"None: Don't sink. This is the default.")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"name: String\n")),Object(r.b)("p",null,"This optional name is used when the configuration is specified in the application.conf file instead of inline in the YAML file.\nThis is useful when the same sink parameters are used for different datasets."),Object(r.b)("h3",{id:"bigquerysink"},"BigQuerySink"),Object(r.b)("p",null,"When the sink type field is set to BQ, the options below shoiuld be provided."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"location: String\n")),Object(r.b)("p",null,"Database location (EU, US, ...)"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"timestamp: String\n")),Object(r.b)("p",null,"The timestamp column to use for table partitioning if any. No partitioning by default"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"clustering: List[String]\n")),Object(r.b)("p",null,"List of ordered columns to use for table clustering"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"days: Int\n")),Object(r.b)("p",null,"Number of days before this table is set as expired and deleted. Never by default."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"requirePartitionFilter: Boolean\n")),Object(r.b)("p",null,"Should be require a partition filter on every request ? No by default."),Object(r.b)("h3",{id:"essink"},"EsSink"),Object(r.b)("p",null,"When the sink ",Object(r.b)("em",{parentName:"p"},"type")," field is set to ES, the options below should be provided.\nElasticsearch options are specified in the application.conf file."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"id: String\n")),Object(r.b)("p",null,"Attribute to use as id of the document. Generated by Elasticseach if not specified."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"timestamp: String\n")),Object(r.b)("p",null,'Timestamp field format as expeted by Elasticsearch ("{beginTs|yyyy.MM.dd}" for example).'),Object(r.b)("h3",{id:"jdbcsink"},"JdbcSink"),Object(r.b)("p",null,"When the sink ",Object(r.b)("em",{parentName:"p"},"type")," field is set to JDBC, the options below should be provided."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"connection: String\n")),Object(r.b)("p",null,"The JDBC Connection String. Specific to the target JDBC database"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"partitions: Int\n")),Object(r.b)("p",null,"Number of Spark partitions"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"batchsize: Int\n")),Object(r.b)("p",null,"Batch size of each JDBC bulk insert"),Object(r.b)("h2",{id:"rowlevelsecurity"},"RowLevelSecurity"),Object(r.b)("p",null,"User / Group and Service accounts rights on a subset of the table."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"name: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". This Row Level Security unique name."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"predicate: String\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". The condition that goes to the WHERE clause and limitt the visible rows."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-scala"},"grants: List[String]\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Required"),". user / groups / service accounts to which this security level is applied.\nFor example: user:",Object(r.b)("a",{parentName:"p",href:"mailto:me@mycompany.com"},"me@mycompany.com"),",group:",Object(r.b)("a",{parentName:"p",href:"mailto:group@mycompany.com"},"group@mycompany.com"),",serviceAccount:",Object(r.b)("a",{parentName:"p",href:"mailto:mysa@google-accounts.com"},"mysa@google-accounts.com")))}o.isMDXComponent=!0},132:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return d}));var n=a(0),l=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var b=l.a.createContext({}),o=function(e){var t=l.a.useContext(b),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=o(e.components);return l.a.createElement(b.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},m=l.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,b=s(e,["components","mdxType","originalType","parentName"]),p=o(a),m=n,d=p["".concat(c,".").concat(m)]||p[m]||u[m]||r;return a?l.a.createElement(d,i(i({ref:t},b),{},{components:a})):l.a.createElement(d,i({ref:t},b))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,c=new Array(r);c[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var b=2;b<r;b++)c[b]=a[b];return l.a.createElement.apply(null,c)}return l.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);